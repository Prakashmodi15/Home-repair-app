<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Naapi Mode — Unlimited Polygon Editor (Prakash)</title>
<style>
:root{--bg:#f6f9ff;--panel:#fff;--accent:#163aa2;--muted:#333}
html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Arial}
.container{max-width:1200px;margin:10px auto;padding:12px}
.header{display:flex;align-items:center;gap:12px;margin-bottom:8px}
.header img{height:54px;border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
.canvasWrap{background:var(--panel);border-radius:10px;padding:10px;box-shadow:0 10px 30px rgba(10,20,40,0.06);position:relative}
#cv{width:100%;height:540px;border-radius:8px;background:#fff;display:block;touch-action:none;cursor:crosshair}
.side{display:grid;grid-template-columns:1fr 380px;gap:12px;margin-top:12px}
.panel{background:var(--panel);padding:10px;border-radius:8px;box-shadow:0 8px 26px rgba(10,20,30,0.04);height:520px;overflow:auto}
.toolbar{display:flex;gap:8px;align-items:center;margin-bottom:8px}
.btn{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
.btn.secondary{background:#eef6ff;color:var(--accent)}
.inputTiny{width:110px;padding:6px;border-radius:6px;border:1px solid #ddd}
.vertexItem{padding:8px;border-radius:8px;border:1px solid #f0f0f0;margin-bottom:8px;background:#fff;display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
.small{font-size:13px;color:var(--muted)}
.inline{position:absolute;display:none;background:#fff;border-radius:8px;padding:8px;box-shadow:0 12px 36px rgba(0,0,0,0.12);z-index:60}
.note{font-size:12px;color:#666}
.kv{font-size:13px;color:#333}
.hr{height:1px;background:#f1f5f9;margin:10px 0;border-radius:2px}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <!-- reference image (local path) -->
    <img src="/mnt/data/Screenshot_20251125_164054_Naapi Amin Land Calculator.jpg" alt="ref"/>
    <div>
      <h2 style="margin:0">Naapi Mode — Unlimited Polygon Editor</h2>
      <div class="note">Canvas ऊपर • Data panel दाहिने • Double-click vertex to edit exact X,Y • Click+move &gt;6px to start drag</div>
    </div>
  </div>

  <div class="canvasWrap">
    <canvas id="cv" tabindex="0"></canvas>
    <div id="inline" class="inline" aria-hidden="true">
      <div id="inlineTitle" style="font-weight:700;margin-bottom:6px">Edit</div>
      <input id="inlineInput" style="width:260px;padding:6px;border:1px solid #ddd;border-radius:6px" />
    </div>
  </div>

  <div class="side">
    <div class="panel" id="leftPanel">
      <div class="toolbar">
        <button id="addPt" class="btn secondary">Add Vertex</button>
        <button id="delPt" class="btn secondary">Delete Selected</button>
        <button id="resetBtn" class="btn secondary">Reset</button>
        <button id="gridToggle" class="btn secondary">Grid</button>
        <button id="constructToggle" class="btn secondary">Construct</button>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <label class="small">Scale (1 unit = meters)</label>
        <input id="unitScale" class="inputTiny" value="1" />
      </div>

      <div class="hr"></div>
      <div class="kv"><strong>Vertices & edit</strong> — क्लिक कर select करें, value बदलते ही shape realtime update होगा</div>
      <div id="vertexList" style="margin-top:10px"></div>
    </div>

    <div class="panel" id="rightPanel">
      <h3 style="margin-top:0">Metrics</h3>
      <div class="kv">Vertices: <span id="vcount">0</span></div>
      <div class="kv">Perimeter: <span id="peri">—</span> units</div>
      <div class="kv">Area (units²): <span id="areaUnits">—</span></div>
      <div class="kv">Area (m²): <span id="areaMeters">—</span></div>
      <div class="kv">Area (ft²): <span id="areaFeet">—</span></div>
      <div class="kv">Area (acres): <span id="areaAcre">—</span></div>

      <div class="hr"></div>
      <div class="note">Editing rules:
        <ul>
          <li>Click points to add while drawing. Click <b>Complete Shape</b> (below) to close.</li>
          <li>Change X/Y → vertex moves.</li>
          <li>Change Length (this→next) → next vertex moved along current direction.</li>
          <li>Change Length (prev→this) → this vertex moved along current direction from prev.</li>
          <li>Change Angle at vertex → next vertex rotated around vertex to satisfy angle (length preserved).</li>
        </ul>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="exportSVG" class="btn">Export SVG</button>
        <button id="exportPNG" class="btn">Export PNG</button>
      </div>
    </div>
  </div>
</div>
<script>
// --- Part 2: helpers, drawing, metrics ---

const canvas = document.getElementById('cv'), ctx = canvas.getContext('2d');
const wrap = document.querySelector('.canvasWrap');
const vertexList = document.getElementById('vertexList');
const inline = document.getElementById('inline'), inlineInput = document.getElementById('inlineInput'), inlineTitle = document.getElementById('inlineTitle');
const periEl = document.getElementById('peri'), areaUnitsEl = document.getElementById('areaUnits'), areaMetersEl = document.getElementById('areaMeters'), areaFeetEl = document.getElementById('areaFeet'), areaAcreEl = document.getElementById('areaAcre');
const vcountEl = document.getElementById('vcount');
const unitScaleEl = document.getElementById('unitScale');

let pxPerUnit = 4.0; // pixels per "unit"
let unitToMeters = parseFloat(unitScaleEl.value) || 1;

let points = [];           // array of {x,y} px (screen coords)
let selectedIdx = null;
let drawingMode = true;    // true while adding points by click
let closed = false;

// drag state
let pointerDown = false, pointerDownIdx = null, pointerDownPos = null, draggingIdx = null;
const DRAG_THRESHOLD = 6;

let showGrid = false, showConstruct = false;

// canvas crisp sizing
function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', ()=>{ fitCanvas(); render(); });
fitCanvas();

// math helpers
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function round2(x){ return Math.round(x*100)/100; }
function toUnits(px){ return px / pxPerUnit; }
function fromUnits(u){ return u * pxPerUnit; }
function deg(r){ return r*180/Math.PI; }
function rad(d){ return d*Math.PI/180; }
function angleBetween(v1,v2){ const dot = v1.x*v2.x + v1.y*v2.y; const det = v1.x*v2.y - v1.y*v2.x; return Math.atan2(det, dot); }
function rotatePointAround(p, center, theta){ const dx = p.x-center.x, dy = p.y-center.y; const cx = dx*Math.cos(theta)-dy*Math.sin(theta); const cy = dx*Math.sin(theta)+dy*Math.cos(theta); return {x:center.x+cx, y:center.y+cy}; }

// polygon metrics
function sideLenPx(i){ if(points.length<2) return 0; const A=points[i], B=points[(i+1)%points.length]; return dist(A,B); }
function sideLenUnits(i){ return toUnits(sideLenPx(i)); }
function internalAngleDeg(i){
  if(points.length<3) return 0;
  const prev = points[(i-1+points.length)%points.length], cur = points[i], next = points[(i+1)%points.length];
  const v1 = {x: prev.x - cur.x, y: prev.y - cur.y}, v2 = {x: next.x - cur.x, y: next.y - cur.y};
  const ang = Math.abs(angleBetween(v1,v2));
  return deg(ang);
}
function perimeterUnits(){ let p=0; for(let i=0;i<points.length;i++) p += sideLenUnits(i); return p; }
function areaUnits(){
  if(points.length<3) return 0;
  let s = 0;
  for(let i=0;i<points.length;i++){
    const a = points[i], b = points[(i+1)%points.length];
    s += a.x*b.y - b.x*a.y;
  }
  const areaPx = Math.abs(s) / 2;
  return (areaPx / (pxPerUnit * pxPerUnit));
}

// draw helpers
function drawGrid(){
  if(!showGrid) return;
  const gap = 25;
  ctx.save();
  ctx.strokeStyle = '#eef6ff'; ctx.lineWidth = 1;
  const w = canvas.width / (window.devicePixelRatio||1);
  const h = canvas.height / (window.devicePixelRatio||1);
  for(let x=0;x<w;x+=gap){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<h;y+=gap){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
  ctx.restore();
}

function angleBisectorPoint(V,P1,P2){
  const a = dist(P1,P2), b = dist(V,P1), c = dist(V,P2);
  if(b < 1e-9 || c < 1e-9) return null;
  const ux = (P1.x - V.x)/b + (P2.x - V.x)/c;
  const uy = (P1.y - V.y)/b + (P2.y - V.y)/c;
  const mag = Math.hypot(ux, uy); if(mag < 1e-9) return null;
  const L = Math.max(30, (b+c)/6);
  return { x: V.x + (ux/mag)*L, y: V.y + (uy/mag)*L };
}

function renderVertexList(){
  vertexList.innerHTML = '';
  for(let i=0;i<points.length;i++){
    const div = document.createElement('div'); div.className = 'vertexItem';
    const left = document.createElement('div'); left.innerHTML = `<strong>Vertex ${i}</strong><div class="small">x:${Math.round(points[i].x)}, y:${Math.round(points[i].y)}</div>`;
    const right = document.createElement('div');
    const lenPrev = round2(toUnits(dist(points[(i-1+points.length)%points.length]||points[i], points[i])));
    const lenNext = round2(toUnits(dist(points[i], points[(i+1)%points.length]||points[i])));
    const ang = points.length >= 3 ? round2(internalAngleDeg(i)) : 0;
    right.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <input data-idx="${i}" data-type="x" class="inputTiny" value="${Math.round(points[i].x)}" />
        <input data-idx="${i}" data-type="y" class="inputTiny" value="${Math.round(points[i].y)}" />
        <div style="display:flex;gap:6px">
          <input data-idx="${i}" data-type="lenPrev" class="inputTiny" title="Length prev->this (units)" value="${lenPrev}" />
          <input data-idx="${i}" data-type="lenNext" class="inputTiny" title="Length this->next (units)" value="${lenNext}" />
        </div>
        <input data-idx="${i}" data-type="angle" class="inputTiny" value="${ang}" />
      </div>
    `;
    div.appendChild(left); div.appendChild(right);
    div.addEventListener('click', ()=>{ selectedIdx = i; render(); });
    setTimeout(()=>{ const ins = div.querySelectorAll('input'); ins.forEach(inp=>{ inp.addEventListener('change', onVertexInputChange); inp.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') inp.blur(); }); }); }, 0);
    vertexList.appendChild(div);
  }
}
<!-- Part 3 -->
<script>
function onVertexInputChange(e){
  const el = e.target, idx = parseInt(el.dataset.idx, 10), type = el.dataset.type, val = parseFloat(el.value);
  if(isNaN(val)) return;
  if(type === 'x'){ points[idx].x = val; render(); return; }
  if(type === 'y'){ points[idx].y = val; render(); return; }
  if(type === 'lenNext'){
    if(points.length < 2) return;
    const A = points[idx], B = points[(idx+1)%points.length];
    const dir = {x: B.x - A.x, y: B.y - A.y};
    const cur = Math.hypot(dir.x, dir.y); if(cur < 1e-9) return;
    const newLenPx = fromUnits(val);
    const s = newLenPx / cur;
    points[(idx+1)%points.length] = { x: A.x + dir.x * s, y: A.y + dir.y * s };
    render(); return;
  }
  if(type === 'lenPrev'){
    if(points.length < 2) return;
    const prev = points[(idx-1+points.length)%points.length], curp = points[idx];
    const dir = { x: curp.x - prev.x, y: curp.y - prev.y };
    const curL = Math.hypot(dir.x, dir.y); if(curL < 1e-9) return;
    const newLenPx = fromUnits(val);
    const s = newLenPx / curL;
    points[idx] = { x: prev.x + dir.x * s, y: prev.y + dir.y * s };
    render(); return;
  }
  if(type === 'angle'){
    if(points.length < 3) return;
    const desiredDeg = val;
    const prev = points[(idx-1+points.length)%points.length], cur = points[idx], next = points[(idx+1)%points.length];
    const vPrev = { x: prev.x - cur.x, y: prev.y - cur.y };
    const vNext = { x: next.x - cur.x, y: next.y - cur.y };
    const signed = angleBetween(vPrev, vNext);
    const desiredRad = Math.abs(rad(desiredDeg));
    const delta = (desiredRad - Math.abs(signed)) * Math.sign(signed || 1);
    const newNextPoint = rotatePointAround({ x: cur.x + vNext.x, y: cur.y + vNext.y }, cur, delta);
    const origLen = Math.hypot(vNext.x, vNext.y);
    const vect = { x: newNextPoint.x - cur.x, y: newNextPoint.y - cur.y };
    const vectLen = Math.hypot(vect.x, vect.y) || 1;
    const scale = origLen / vectLen;
    points[(idx+1)%points.length] = { x: cur.x + vect.x * scale, y: cur.y + vect.y * scale };
    render(); return;
  }
}

// pointer interactions: drawing mode & drag mode
canvas.addEventListener('pointerdown', (ev)=>{
  ev.preventDefault();
  const rect = canvas.getBoundingClientRect(); const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  if(drawingMode){
    // add point by clicks while drawingMode true
    points.push({ x: Math.round(x), y: Math.round(y) });
    render();
    return;
  }
  // if not drawing, allow vertex selection and drag-on-threshold
  pointerDown = true; pointerDownPos = {x,y}; pointerDownIdx = hitVertex(x,y);
});

canvas.addEventListener('pointermove', (ev)=>{
  const rect = canvas.getBoundingClientRect(); const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  if(!drawingMode && pointerDown && pointerDownIdx !== null && draggingIdx === null){
    const dx = x - pointerDownPos.x, dy = y - pointerDownPos.y;
    if(Math.hypot(dx,dy) >= DRAG_THRESHOLD) draggingIdx = pointerDownIdx;
    else return;
  }
  if(draggingIdx !== null){
    points[draggingIdx].x = Math.round(x); points[draggingIdx].y = Math.round(y); render();
  }
});

canvas.addEventListener('pointerup', (ev)=>{
  if(drawingMode) return; // nothing
  pointerDown = false; pointerDownIdx = null; draggingIdx = null;
});

canvas.addEventListener('dblclick', (ev)=>{
  const rect = canvas.getBoundingClientRect(); const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  const idx = hitVertex(x, y); if(idx === null) return;
  openInlineVertex(idx, x, y);
});

function hitVertex(x, y){
  for(let i=0;i<points.length;i++){ if(Math.hypot(points[i].x - x, points[i].y - y) < 12) return i; }
  return null;
}

// inline editor (double-click)
let popupTarget = null;
function openInlineVertex(idx, clientX, clientY){
  popupTarget = { type:'vertex', idx };
  inlineTitle.textContent = 'Vertex ' + idx + ' (x,y)';
  inlineInput.value = Math.round(points[idx].x) + ', ' + Math.round(points[idx].y);
  showInlineAt(clientX, clientY);
  inlineInput.focus(); inlineInput.select();
}
function showInlineAt(clientX, clientY){
  const rect = wrap.getBoundingClientRect();
  let left = clientX - rect.left + 6, top = clientY - rect.top + 6;
  left = Math.min(left, rect.width - 280); top = Math.min(top, rect.height - 80);
  inline.style.left = left + 'px'; inline.style.top = top + 'px'; inline.style.display = 'block'; inline.setAttribute('aria-hidden', 'false');
}
function hideInline(){ inline.style.display='none'; inline.setAttribute('aria-hidden','true'); popupTarget = null; }
inlineInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ applyInline(); } if(e.key === 'Escape'){ hideInline(); }});
function applyInline(){
  if(!popupTarget) { hideInline(); return; }
  if(popupTarget.type === 'vertex'){
    const parts = inlineInput.value.split(',').map(s=>parseFloat(s.trim()));
    if(parts.length>=2 && !isNaN(parts[0]) && !isNaN(parts[1])){
      points[popupTarget.idx].x = parts[0]; points[popupTarget.idx].y = parts[1]; render(); hideInline(); return;
    } else { alert('Enter valid x,y numbers'); return; }
  }
}

// finish / complete shape button
document.getElementById('addPt').addEventListener('click', ()=>{ if(!drawingMode){ addVertex(); } else { alert('While drawing, just click on canvas to add points. Use Complete/Finish button to close.'); } });

// Finish button: we will use double function — if drawingMode true, complete shape; else toggle drawing mode
const finishBtn = (function(){
  // create a small "Complete shape" control under left panel by reusing resetBtn area
  const b = document.createElement('button'); b.textContent = 'Complete Shape'; b.className = 'btn secondary'; b.style.marginLeft='6px';
  b.addEventListener('click', ()=>{ if(points.length >= 3){ drawingMode = false; closed = true; render(); } else alert('At least 3 points required'); });
  document.querySelector('.toolbar').appendChild(b);
  return b;
})();

// reset
document.getElementById('resetBtn').addEventListener('click', ()=>{
  points = []; drawingMode = true; closed = false; selectedIdx = null; render();
});

// del selected
document.getElementById('delPt').addEventListener('click', ()=>{
  if(selectedIdx !== null && selectedIdx >= 0 && selectedIdx < points.length){
    points.splice(selectedIdx,1); selectedIdx = null; render();
  } else alert('Select a vertex first (click on vertex).');
});

// grid & construct toggles
document.getElementById('gridToggle').addEventListener('click',(e)=>{ showGrid = !showGrid; e.target.textContent = showGrid? 'Grid: ON':'Grid'; render(); });
document.getElementById('constructToggle').addEventListener('click',(e)=>{ showConstruct = !showConstruct; e.target.textContent = showConstruct? 'Construct: ON':'Construct'; render(); });

// export functions
document.getElementById('exportSVG').addEventListener('click', exportSVG);
document.getElementById('exportPNG').addEventListener('click', exportPNG);

function exportSVG(){
  if(points.length < 2){ alert('No polygon'); return; }
  const svgW = canvas.width / (window.devicePixelRatio||1), svgH = canvas.height / (window.devicePixelRatio||1);
  let path = '';
  points.forEach((p,i)=>{ path += (i===0? 'M' : 'L') + p.x + ' ' + p.y + ' '; });
  if(points.length >= 3) path += 'Z';
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}"><path d="${path}" fill="none" stroke="#163aa2" stroke-width="4" stroke-linejoin="round" stroke-linecap="round" /></svg>`;
  const blob = new Blob([svg], { type:'image/svg+xml' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'polygon.svg'; a.click(); URL.revokeObjectURL(url);
}
function exportPNG(){ const link = document.createElement('a'); link.download = 'polygon.png'; link.href = canvas.toDataURL('image/png'); link.click(); }

// hit test
function hitVertex(x, y){
  for(let i=0;i<points.length;i++){ if(Math.hypot(points[i].x - x, points[i].y - y) < 12) return i; }
  return null;
}

// add vertex programmatically (used when not drawing)
function addVertex(){
  const cx = (canvas.getBoundingClientRect().width)/2 + (Math.random()*120 - 60);
  const cy = (canvas.getBoundingClientRect().height)/2 + (Math.random()*120 - 60);
  points.push({ x: Math.round(cx), y: Math.round(cy) });
  render();
}

// initial: small helper UI (Complete button created above)
resetSample();
function resetSample(){
  points = [
    {x:140,y:180},{x:300,y:140},{x:460,y:190}
  ];
  drawingMode = false; closed = true; selectedIdx = null; render();
}

// render: draw on canvas + update side labels + metrics + vertex list
function render(){
  fitCanvas();
  const w = canvas.width / (window.devicePixelRatio||1);
  const h = canvas.height / (window.devicePixelRatio||1);
  ctx.clearRect(0,0,w,h);

  // grid
  if(showGrid){
    const gap = 25;
    ctx.save(); ctx.strokeStyle = '#eef6ff'; ctx.lineWidth = 1;
    for(let x=0;x<w;x+=gap){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=gap){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();
  }

  // while drawingMode true: draw polyline (not closed) as user clicks
  if(points.length > 0){
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
    if(closed) ctx.closePath();
    ctx.lineWidth = 2; ctx.strokeStyle = '#163aa2'; ctx.stroke();
  }

  // draw edge length labels only if closed
  if(closed && points.length >= 2){
    for(let i=0;i<points.length;i++){
      const A = points[i], B = points[(i+1)%points.length];
      const mx = (A.x + B.x)/2, my = (A.y + B.y)/2;
      const lenU = round2(toUnits(dist(A,B)));
      ctx.font = '13px system-ui'; ctx.fillStyle = '#000'; ctx.fillText(lenU, mx + 8, my - 6);
      // perpendicular tick
      ctx.beginPath();
      const dx = B.x - A.x, dy = B.y - A.y; const nx = -dy, ny = dx; const nlen = Math.hypot(nx, ny) || 1;
      ctx.moveTo(mx - (nx/nlen)*6, my - (ny/nlen)*6); ctx.lineTo(mx + (nx/nlen)*6, my + (ny/nlen)*6);
      ctx.strokeStyle = '#e6eef8'; ctx.lineWidth = 1; ctx.stroke();
    }
  }

  // draw vertices & angles
  for(let i=0;i<points.length;i++){
    const p = points[i];
    ctx.beginPath(); ctx.fillStyle = (i===selectedIdx)? '#0b74de' : '#000'; ctx.arc(p.x,p.y, (i===selectedIdx)?8:6, 0, Math.PI*2); ctx.fill();
    ctx.font = '12px system-ui'; ctx.fillStyle = '#111'; ctx.fillText('#' + i, p.x + 10, p.y - 8);
    if(closed && points.length >= 3){
      ctx.fillText('θ=' + round2(internalAngleDeg(i)) + '°', p.x + 10, p.y + 14);
    }
  }

  // metrics update
  vcountEl.textContent = points.length;
  periEl.textContent = points.length >= 2 ? round2(perimeterUnits()) : '—';
  const areaU = areaUnits();
  areaUnitsEl.textContent = points.length >= 3 ? round2(areaU) : '—';
  const areaM = areaU * (unitToMeters * unitToMeters);
  areaMetersEl.textContent = points.length >= 3 ? round2(areaM) + ' m²' : '—';
  areaFeetEl.textContent = points.length >= 3 ? round2(areaM * 10.76391) + ' ft²' : '—';
  areaAcreEl.textContent = points.length >= 3 ? round2(areaM / 4046.85642) + ' acres' : '—';

  // vertex list
  renderVertexList();
}
</script>
</body>
</html>
